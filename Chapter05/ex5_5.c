/* ex5_5.c
 *
 * Программа 5.5 Пример рекурсивных функция для связных списков
 *
 * Эти рекурсивные функции для выполнения простых задач обработки списков
 * легко выразить, но они могут оказаться бесполезными для очень больших
 * списков, поскольку глубина рекурсии может быть пропорциональна
 * длине такого списка.
*/

#include "../Chapter04/"

/* Функция подсчитывает число узлов в списке.
 * Альтернатива реализуется с помощью for / while.
 */
int count(Link x){
	if (x == NULL){
		return 0;
	}
	return 1 + count(x->next);
}


/* Функция вызывает функцию visit для каждого узла списка, с начала и до конца. 
 * Альтернатива реализуется с помощью for / while.
 */
void traverse(Link h, void visit(*Link)){
	if (h == NULL){
		return;
	}
	(*visit)(h);
	traverse(h->next, *visit);
}

/* Функция вызывает функцию visit для каждого узла списка в обратном порядке.
 */
void traverse(RLink h, void visit(*Link)){
	if (h == NULL){
		return;
	}
	traverse(h->next, *visit);
	(*visit)(h);
}

/* Функция производит все структурные изменения, необходимые для
 * того, чтобы удалить заданный элемент из списка.
 * Она возвращает ссылку на (возможно измененную) оставшуюся часть
 * списка - возвращаемая ссылка есть х, за исключением случая, когда
 * x->item есть v, в этом случае возвращаемая ссылка есть x->next
 * (реккурсия заверщается)
 .*/
Link delete(Link x, Item v){
	if (x == NULL){
		return NULL;
	}
	else if(eq(x->item, v)){
		Link tmp = x->next;
		free(x);
		return tmp;
	}
	x->next = delete(x->next, v);
	return x;
}